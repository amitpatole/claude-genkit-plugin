{
  "Genkit Flow": {
    "prefix": "gflow",
    "body": [
      "import { defineFlow } from '@genkit-ai/flow';",
      "import { z } from 'zod';",
      "",
      "export const ${1:flowName}Flow = defineFlow(",
      "  {",
      "    name: '${1:flowName}',",
      "    inputSchema: z.object({",
      "      ${2:input}: z.string(),",
      "    }),",
      "    outputSchema: z.${3:string}(),",
      "  },",
      "  async (input) => {",
      "    ${4:// Implement flow logic}",
      "    return ${5:input.${2:input}};",
      "  }",
      ");"
    ],
    "description": "Create a new Genkit flow"
  },
  "Genkit Tool": {
    "prefix": "gtool",
    "body": [
      "import { defineTool } from '@genkit-ai/flow';",
      "import { z } from 'zod';",
      "",
      "export const ${1:toolName}Tool = defineTool(",
      "  {",
      "    name: '${1:toolName}',",
      "    description: '${2:Tool description}',",
      "    inputSchema: z.object({",
      "      ${3:param}: z.string(),",
      "    }),",
      "    outputSchema: z.${4:string}(),",
      "  },",
      "  async (input) => {",
      "    ${5:// Implement tool logic}",
      "    return ${6:result};",
      "  }",
      ");"
    ],
    "description": "Create a new Genkit tool"
  },
  "Genkit RAG Flow": {
    "prefix": "grag",
    "body": [
      "import { defineFlow } from '@genkit-ai/flow';",
      "import { z } from 'zod';",
      "",
      "export const ${1:ragFlow} = defineFlow(",
      "  {",
      "    name: '${1:ragFlow}',",
      "    inputSchema: z.object({",
      "      question: z.string(),",
      "      maxResults: z.number().default(5),",
      "    }),",
      "    outputSchema: z.object({",
      "      answer: z.string(),",
      "      sources: z.array(z.string()),",
      "    }),",
      "  },",
      "  async (input) => {",
      "    // Retrieve relevant documents",
      "    const docs = await ${2:vectorStore}.search(input.question, {",
      "      limit: input.maxResults,",
      "    });",
      "",
      "    // Generate answer with context",
      "    const result = await ${3:model}.generate({",
      "      prompt: `Context:\\n${4:\\${docs.map(d => d.content).join('\\n\\n')}}\\n\\nQuestion: ${5:\\${input.question}}\\n\\nAnswer:`,",
      "    });",
      "",
      "    return {",
      "      answer: result.text,",
      "      sources: docs.map(d => d.id),",
      "    };",
      "  }",
      ");"
    ],
    "description": "Create a RAG flow with Genkit"
  },
  "Genkit Config": {
    "prefix": "gconfig",
    "body": [
      "import { configureGenkit } from '@genkit-ai/core';",
      "import { ${1:claude} } from '@genkit-ai/${2:anthropic}';",
      "",
      "export default configureGenkit({",
      "  plugins: [",
      "    ${1:claude}({",
      "      apiKey: process.env.${3:ANTHROPIC_API_KEY},",
      "    }),",
      "  ],",
      "  logLevel: '${4:debug}',",
      "  enableTracingAndMetrics: ${5:true},",
      "});"
    ],
    "description": "Create Genkit configuration"
  },
  "Genkit Streaming Flow": {
    "prefix": "gstream",
    "body": [
      "import { defineFlow } from '@genkit-ai/flow';",
      "import { z } from 'zod';",
      "",
      "export const ${1:streamFlow} = defineFlow(",
      "  {",
      "    name: '${1:streamFlow}',",
      "    inputSchema: z.object({",
      "      prompt: z.string(),",
      "    }),",
      "    outputSchema: z.string(),",
      "    streamSchema: z.string(),",
      "  },",
      "  async (input, { stream }) => {",
      "    ${2:// Implement streaming logic}",
      "    for (const ${3:chunk} of ${4:chunks}) {",
      "      stream(${3:chunk});",
      "      await new Promise(resolve => setTimeout(resolve, ${5:100}));",
      "    }",
      "    return ${6:'Complete response'};",
      "  }",
      ");"
    ],
    "description": "Create a streaming Genkit flow"
  },
  "Claude Generate": {
    "prefix": "genclaude",
    "body": [
      "import { claude35Sonnet } from '@genkit-ai/anthropic';",
      "",
      "const result = await claude35Sonnet.generate({",
      "  ${1|prompt,messages|}: ${2:'Your prompt here'},",
      "  config: {",
      "    temperature: ${3:0.7},",
      "    maxTokens: ${4:1000},",
      "  },",
      "});",
      "",
      "const response = result.text;"
    ],
    "description": "Generate with Claude"
  },
  "Gemini Generate": {
    "prefix": "gengemini",
    "body": [
      "import { gemini15Pro } from '@genkit-ai/googleai';",
      "",
      "const result = await gemini15Pro.generate({",
      "  ${1|prompt,messages|}: ${2:'Your prompt here'},",
      "  config: {",
      "    temperature: ${3:0.7},",
      "    maxTokens: ${4:1000},",
      "  },",
      "});",
      "",
      "const response = result.text;"
    ],
    "description": "Generate with Gemini"
  },
  "Hybrid Search RAG": {
    "prefix": "grag-hybrid",
    "body": [
      "import { defineFlow } from '@genkit-ai/flow';",
      "import { z } from 'zod';",
      "",
      "export const ${1:hybridSearchRAG} = defineFlow(",
      "  {",
      "    name: '${1:hybridSearchRAG}',",
      "    inputSchema: z.object({",
      "      query: z.string(),",
      "      semanticWeight: z.number().default(0.7),",
      "      keywordWeight: z.number().default(0.3),",
      "    }),",
      "    outputSchema: z.object({",
      "      answer: z.string(),",
      "      sources: z.array(z.object({ id: z.string(), score: z.number() })),",
      "    }),",
      "  },",
      "  async (input) => {",
      "    // Semantic search",
      "    const semanticResults = await ${2:vectorStore}.search(input.query);",
      "    ",
      "    // Keyword search",
      "    const keywordResults = await ${3:fullTextSearch}.search(input.query);",
      "    ",
      "    // Combine and rerank",
      "    const combined = rerank(semanticResults, keywordResults, {",
      "      semanticWeight: input.semanticWeight,",
      "      keywordWeight: input.keywordWeight,",
      "    });",
      "    ",
      "    const answer = await ${4:model}.generate({",
      "      context: combined.map(r => r.content).join('\\n\\n'),",
      "      question: input.query,",
      "    });",
      "    ",
      "    return { answer: answer.text, sources: combined };",
      "  }",
      ");"
    ],
    "description": "Create Hybrid Search RAG flow (semantic + keyword)"
  },
  "Hierarchical RAG": {
    "prefix": "grag-hierarchical",
    "body": [
      "import { defineFlow } from '@genkit-ai/flow';",
      "import { z } from 'zod';",
      "",
      "export const ${1:hierarchicalRAG} = defineFlow(",
      "  {",
      "    name: '${1:hierarchicalRAG}',",
      "    inputSchema: z.object({",
      "      query: z.string(),",
      "    }),",
      "    outputSchema: z.string(),",
      "  },",
      "  async (input) => {",
      "    // Level 1: Find relevant documents",
      "    const documents = await ${2:vectorStore}.search(input.query, {",
      "      level: 'document',",
      "      limit: 5,",
      "    });",
      "    ",
      "    // Level 2: Find relevant sections within documents",
      "    const sections = await Promise.all(",
      "      documents.map(doc => ",
      "        ${2:vectorStore}.search(input.query, {",
      "          level: 'section',",
      "          parentId: doc.id,",
      "          limit: 3,",
      "        })",
      "      )",
      "    );",
      "    ",
      "    // Level 3: Find specific chunks",
      "    const chunks = sections.flat().map(s => s.chunks).flat();",
      "    ",
      "    const answer = await ${3:model}.generate({",
      "      context: chunks.join('\\n\\n'),",
      "      question: input.query,",
      "    });",
      "    ",
      "    return answer.text;",
      "  }",
      ");"
    ],
    "description": "Create Hierarchical RAG flow (multi-level retrieval)"
  },
  "Conversational RAG": {
    "prefix": "grag-conversational",
    "body": [
      "import { defineFlow } from '@genkit-ai/flow';",
      "import { z } from 'zod';",
      "",
      "export const ${1:conversationalRAG} = defineFlow(",
      "  {",
      "    name: '${1:conversationalRAG}',",
      "    inputSchema: z.object({",
      "      query: z.string(),",
      "      conversationHistory: z.array(z.object({",
      "        role: z.enum(['user', 'assistant']),",
      "        content: z.string(),",
      "      })),",
      "    }),",
      "    outputSchema: z.string(),",
      "  },",
      "  async (input) => {",
      "    // Reformulate query with conversation context",
      "    const contextualQuery = await ${2:model}.generate({",
      "      prompt: `Given the conversation history, reformulate the latest query:\\n${3:\\${JSON.stringify(input.conversationHistory)}}\\n\\nLatest query: ${4:\\${input.query}}\\n\\nReformulated query:`,",
      "    });",
      "    ",
      "    // Retrieve with contextual query",
      "    const docs = await ${5:vectorStore}.search(contextualQuery.text);",
      "    ",
      "    // Generate answer with full context",
      "    const answer = await ${2:model}.generate({",
      "      messages: [",
      "        ...input.conversationHistory,",
      "        { role: 'user', content: `Context:\\n${6:\\${docs.map(d => d.content).join('\\n\\n')}}\\n\\nQuestion: ${4:\\${input.query}}` },",
      "      ],",
      "    });",
      "    ",
      "    return answer.text;",
      "  }",
      ");"
    ],
    "description": "Create Conversational RAG flow (context-aware)"
  },
  "Multi-Query RAG": {
    "prefix": "grag-multiquery",
    "body": [
      "import { defineFlow } from '@genkit-ai/flow';",
      "import { z } from 'zod';",
      "",
      "export const ${1:multiQueryRAG} = defineFlow(",
      "  {",
      "    name: '${1:multiQueryRAG}',",
      "    inputSchema: z.object({",
      "      query: z.string(),",
      "      numQueries: z.number().default(3),",
      "    }),",
      "    outputSchema: z.string(),",
      "  },",
      "  async (input) => {",
      "    // Generate multiple query variations",
      "    const queries = await ${2:model}.generate({",
      "      prompt: `Generate ${3:\\${input.numQueries}} different variations of this query: \"${4:\\${input.query}}\"\\n\\nVariations:`,",
      "    });",
      "    ",
      "    const queryList = queries.text.split('\\n').filter(q => q.trim());",
      "    ",
      "    // Search with all query variations",
      "    const allResults = await Promise.all(",
      "      queryList.map(q => ${5:vectorStore}.search(q))",
      "    );",
      "    ",
      "    // Deduplicate and rank results",
      "    const uniqueDocs = deduplicateAndRank(allResults.flat());",
      "    ",
      "    const answer = await ${2:model}.generate({",
      "      context: uniqueDocs.map(d => d.content).join('\\n\\n'),",
      "      question: input.query,",
      "    });",
      "    ",
      "    return answer.text;",
      "  }",
      ");"
    ],
    "description": "Create Multi-Query RAG flow (query expansion)"
  },
  "Self-Querying RAG": {
    "prefix": "grag-selfquery",
    "body": [
      "import { defineFlow } from '@genkit-ai/flow';",
      "import { z } from 'zod';",
      "",
      "export const ${1:selfQueryingRAG} = defineFlow(",
      "  {",
      "    name: '${1:selfQueryingRAG}',",
      "    inputSchema: z.object({",
      "      query: z.string(),",
      "    }),",
      "    outputSchema: z.string(),",
      "  },",
      "  async (input) => {",
      "    // Extract metadata filters from query",
      "    const filterExtraction = await ${2:model}.generate({",
      "      prompt: `Extract search filters from this query: \"${3:\\${input.query}}\"\\n\\nReturn JSON with filters for: date, category, author, tags`,",
      "    });",
      "    ",
      "    const filters = JSON.parse(filterExtraction.text);",
      "    ",
      "    // Search with semantic query and metadata filters",
      "    const docs = await ${4:vectorStore}.search(input.query, {",
      "      filter: filters,",
      "      limit: 10,",
      "    });",
      "    ",
      "    const answer = await ${2:model}.generate({",
      "      context: docs.map(d => d.content).join('\\n\\n'),",
      "      question: input.query,",
      "    });",
      "    ",
      "    return answer.text;",
      "  }",
      ");"
    ],
    "description": "Create Self-Querying RAG flow (metadata filtering)"
  },
  "Parent-Child RAG": {
    "prefix": "grag-parentchild",
    "body": [
      "import { defineFlow } from '@genkit-ai/flow';",
      "import { z } from 'zod';",
      "",
      "export const ${1:parentChildRAG} = defineFlow(",
      "  {",
      "    name: '${1:parentChildRAG}',",
      "    inputSchema: z.object({",
      "      query: z.string(),",
      "    }),",
      "    outputSchema: z.string(),",
      "  },",
      "  async (input) => {",
      "    // Search using small child chunks for precision",
      "    const childChunks = await ${2:vectorStore}.search(input.query, {",
      "      chunkType: 'child',",
      "      limit: 10,",
      "    });",
      "    ",
      "    // Retrieve larger parent chunks for context",
      "    const parentChunks = await Promise.all(",
      "      childChunks.map(child => ",
      "        ${2:vectorStore}.getById(child.parentId)",
      "      )",
      "    );",
      "    ",
      "    // Use parent chunks for generation",
      "    const answer = await ${3:model}.generate({",
      "      context: parentChunks.map(p => p.content).join('\\n\\n'),",
      "      question: input.query,",
      "    });",
      "    ",
      "    return answer.text;",
      "  }",
      ");"
    ],
    "description": "Create Parent-Child RAG flow (document chunking strategy)"
  },
  "Corrective RAG": {
    "prefix": "grag-corrective",
    "body": [
      "import { defineFlow } from '@genkit-ai/flow';",
      "import { z } from 'zod';",
      "",
      "export const ${1:correctiveRAG} = defineFlow(",
      "  {",
      "    name: '${1:correctiveRAG}',",
      "    inputSchema: z.object({",
      "      query: z.string(),",
      "    }),",
      "    outputSchema: z.string(),",
      "  },",
      "  async (input) => {",
      "    // Initial retrieval",
      "    const docs = await ${2:vectorStore}.search(input.query);",
      "    ",
      "    // Evaluate relevance of retrieved documents",
      "    const relevanceScores = await ${3:model}.generate({",
      "      prompt: `Rate the relevance of each document to the query \"${4:\\${input.query}}\" (0-10):\\n${5:\\${docs.map((d, i) => `Doc ${6:\\${i}}: ${7:\\${d.content.substring(0, 200)}}`).join('\\n\\n')}}`,",
      "    });",
      "    ",
      "    const scores = parseScores(relevanceScores.text);",
      "    ",
      "    // If relevance is low, try web search or different retrieval strategy",
      "    let finalDocs = docs;",
      "    if (Math.max(...scores) < 7) {",
      "      finalDocs = await alternateRetrieval(input.query);",
      "    }",
      "    ",
      "    const answer = await ${3:model}.generate({",
      "      context: finalDocs.map(d => d.content).join('\\n\\n'),",
      "      question: input.query,",
      "    });",
      "    ",
      "    return answer.text;",
      "  }",
      ");"
    ],
    "description": "Create Corrective RAG flow (self-correction)"
  },
  "Adaptive RAG": {
    "prefix": "grag-adaptive",
    "body": [
      "import { defineFlow } from '@genkit-ai/flow';",
      "import { z } from 'zod';",
      "",
      "export const ${1:adaptiveRAG} = defineFlow(",
      "  {",
      "    name: '${1:adaptiveRAG}',",
      "    inputSchema: z.object({",
      "      query: z.string(),",
      "    }),",
      "    outputSchema: z.string(),",
      "  },",
      "  async (input) => {",
      "    // Classify query complexity",
      "    const classification = await ${2:model}.generate({",
      "      prompt: `Classify this query complexity (simple/medium/complex): \"${3:\\${input.query}}\"`,",
      "    });",
      "    ",
      "    let docs;",
      "    const complexity = classification.text.toLowerCase();",
      "    ",
      "    // Choose retrieval strategy based on complexity",
      "    if (complexity.includes('simple')) {",
      "      docs = await ${4:vectorStore}.search(input.query, { limit: 3 });",
      "    } else if (complexity.includes('medium')) {",
      "      docs = await hybridSearch(input.query);",
      "    } else {",
      "      docs = await multiQuerySearch(input.query);",
      "    }",
      "    ",
      "    const answer = await ${2:model}.generate({",
      "      context: docs.map(d => d.content).join('\\n\\n'),",
      "      question: input.query,",
      "    });",
      "    ",
      "    return answer.text;",
      "  }",
      ");"
    ],
    "description": "Create Adaptive RAG flow (dynamic strategy selection)"
  },
  "Pinecone Vector Setup": {
    "prefix": "gvector-pinecone",
    "body": [
      "import { Pinecone } from '@pinecone-database/pinecone';",
      "import { embed } from '@genkit-ai/ai';",
      "",
      "const pinecone = new Pinecone({",
      "  apiKey: process.env.PINECONE_API_KEY!,",
      "});",
      "",
      "const index = pinecone.Index('${1:your-index-name}');",
      "",
      "export async function addDocuments(documents: Array<{ id: string; content: string; metadata?: any }>) {",
      "  const vectors = await Promise.all(",
      "    documents.map(async (doc) => ({",
      "      id: doc.id,",
      "      values: await embed({ content: doc.content }),",
      "      metadata: { content: doc.content, ...doc.metadata },",
      "    }))",
      "  );",
      "  ",
      "  await index.upsert(vectors);",
      "}",
      "",
      "export async function search(query: string, limit = 5) {",
      "  const queryVector = await embed({ content: query });",
      "  const results = await index.query({",
      "    vector: queryVector,",
      "    topK: limit,",
      "    includeMetadata: true,",
      "  });",
      "  return results.matches;",
      "}"
    ],
    "description": "Setup Pinecone vector database"
  },
  "Chroma Vector Setup": {
    "prefix": "gvector-chroma",
    "body": [
      "import { ChromaClient } from 'chromadb';",
      "import { embed } from '@genkit-ai/ai';",
      "",
      "const client = new ChromaClient();",
      "const collection = await client.getOrCreateCollection({",
      "  name: '${1:my-collection}',",
      "});",
      "",
      "export async function addDocuments(documents: Array<{ id: string; content: string; metadata?: any }>) {",
      "  const embeddings = await Promise.all(",
      "    documents.map(doc => embed({ content: doc.content }))",
      "  );",
      "  ",
      "  await collection.add({",
      "    ids: documents.map(d => d.id),",
      "    embeddings,",
      "    documents: documents.map(d => d.content),",
      "    metadatas: documents.map(d => d.metadata),",
      "  });",
      "}",
      "",
      "export async function search(query: string, limit = 5) {",
      "  const queryEmbedding = await embed({ content: query });",
      "  const results = await collection.query({",
      "    queryEmbeddings: [queryEmbedding],",
      "    nResults: limit,",
      "  });",
      "  return results;",
      "}"
    ],
    "description": "Setup Chroma vector database"
  },
  "WebSocket Real-Time Flow": {
    "prefix": "gwebsocket",
    "body": [
      "import { defineFlow } from '@genkit-ai/flow';",
      "import { z } from 'zod';",
      "import { WebSocket, WebSocketServer } from 'ws';",
      "",
      "const wss = new WebSocketServer({ port: ${1:8080} });",
      "",
      "export const ${2:wsFlow} = defineFlow(",
      "  {",
      "    name: '${2:wsFlow}',",
      "    inputSchema: z.object({",
      "      message: z.string(),",
      "    }),",
      "    outputSchema: z.string(),",
      "  },",
      "  async (input) => {",
      "    const result = await ${3:model}.generate({",
      "      prompt: input.message,",
      "    });",
      "    ",
      "    // Broadcast to all connected clients",
      "    wss.clients.forEach((client) => {",
      "      if (client.readyState === WebSocket.OPEN) {",
      "        client.send(JSON.stringify({",
      "          type: 'response',",
      "          data: result.text,",
      "        }));",
      "      }",
      "    });",
      "    ",
      "    return result.text;",
      "  }",
      ");",
      "",
      "wss.on('connection', (ws) => {",
      "  ws.on('message', async (data) => {",
      "    const message = JSON.parse(data.toString());",
      "    await ${2:wsFlow}(message);",
      "  });",
      "});"
    ],
    "description": "Create WebSocket real-time flow"
  },
  "Server-Sent Events Flow": {
    "prefix": "gsse",
    "body": [
      "import { defineFlow } from '@genkit-ai/flow';",
      "import { z } from 'zod';",
      "import express from 'express';",
      "",
      "const app = express();",
      "",
      "export const ${1:sseFlow} = defineFlow(",
      "  {",
      "    name: '${1:sseFlow}',",
      "    inputSchema: z.object({",
      "      prompt: z.string(),",
      "    }),",
      "    outputSchema: z.string(),",
      "    streamSchema: z.string(),",
      "  },",
      "  async (input, { stream }) => {",
      "    const result = await ${2:model}.generate({",
      "      prompt: input.prompt,",
      "      stream: true,",
      "    });",
      "    ",
      "    for await (const chunk of result.stream) {",
      "      stream(chunk.text);",
      "    }",
      "    ",
      "    return result.text;",
      "  }",
      ");",
      "",
      "app.get('/stream', async (req, res) => {",
      "  res.setHeader('Content-Type', 'text/event-stream');",
      "  res.setHeader('Cache-Control', 'no-cache');",
      "  res.setHeader('Connection', 'keep-alive');",
      "  ",
      "  const { prompt } = req.query;",
      "  ",
      "  await ${1:sseFlow}({ prompt: prompt as string }, {",
      "    stream: (chunk) => {",
      "      res.write(`data: ${3:\\${JSON.stringify({ chunk })}}\\n\\n`);",
      "    },",
      "  });",
      "  ",
      "  res.end();",
      "});",
      "",
      "app.listen(${4:3000});"
    ],
    "description": "Create Server-Sent Events (SSE) streaming flow"
  },
  "Genkit Model Plugin": {
    "prefix": "gplugin-model",
    "body": [
      "import { defineModel } from '@genkit-ai/ai/model';",
      "import { z } from 'zod';",
      "",
      "export const ${1:customModel} = defineModel(",
      "  {",
      "    name: '${2:my-provider}/${1:customModel}',",
      "    label: '${3:My Custom Model}',",
      "    supports: {",
      "      multiturn: ${4:true},",
      "      media: ${5:false},",
      "      tools: ${6:true},",
      "      systemRole: ${7:true},",
      "    },",
      "  },",
      "  async (request) => {",
      "    // Call your model API",
      "    const response = await fetch('${8:https://api.example.com/generate}', {",
      "      method: 'POST',",
      "      headers: {",
      "        'Content-Type': 'application/json',",
      "        'Authorization': `Bearer ${9:\\${process.env.API_KEY}}`,",
      "      },",
      "      body: JSON.stringify({",
      "        prompt: request.messages[0].content,",
      "        temperature: request.config?.temperature,",
      "        max_tokens: request.config?.maxTokens,",
      "      }),",
      "    });",
      "    ",
      "    const data = await response.json();",
      "    ",
      "    return {",
      "      message: {",
      "        role: 'model',",
      "        content: [{ text: data.text }],",
      "      },",
      "      finishReason: 'stop',",
      "    };",
      "  }",
      ");"
    ],
    "description": "Create a custom Genkit model plugin"
  },
  "Genkit Retriever Plugin": {
    "prefix": "gplugin-retriever",
    "body": [
      "import { defineRetriever } from '@genkit-ai/ai/retriever';",
      "import { z } from 'zod';",
      "",
      "export const ${1:customRetriever} = defineRetriever(",
      "  {",
      "    name: '${2:my-provider}/${1:customRetriever}',",
      "    configSchema: z.object({",
      "      limit: z.number().default(10),",
      "      threshold: z.number().default(0.7),",
      "    }),",
      "  },",
      "  async (query, config) => {",
      "    // Implement your retrieval logic",
      "    const results = await ${3:yourVectorDB}.search(query.text, {",
      "      limit: config.limit,",
      "      threshold: config.threshold,",
      "    });",
      "    ",
      "    return {",
      "      documents: results.map(result => ({",
      "        content: [{",
      "          text: result.content,",
      "        }],",
      "        metadata: {",
      "          score: result.score,",
      "          ...result.metadata,",
      "        },",
      "      })),",
      "    };",
      "  }",
      ");"
    ],
    "description": "Create a custom Genkit retriever plugin"
  },
  "Multi-Region Config": {
    "prefix": "gregion-config",
    "body": [
      "export const multiRegionConfig = {",
      "  strategy: '${1|active-active,active-passive,geo-routing|}',",
      "  regions: [",
      "    {",
      "      name: '${2:us-central1}',",
      "      primary: ${3:true},",
      "      weight: ${4:50},",
      "      endpoints: {",
      "        api: 'https://${2:us-central1}.example.com',",
      "        health: 'https://${2:us-central1}.example.com/health',",
      "      },",
      "    },",
      "    {",
      "      name: '${5:europe-west1}',",
      "      primary: ${6:false},",
      "      weight: ${7:50},",
      "      endpoints: {",
      "        api: 'https://${5:europe-west1}.example.com',",
      "        health: 'https://${5:europe-west1}.example.com/health',",
      "      },",
      "    },",
      "  ],",
      "  failover: {",
      "    enabled: ${8:true},",
      "    healthCheckInterval: ${9:30000},",
      "    retryAttempts: ${10:3},",
      "  },",
      "};"
    ],
    "description": "Create multi-region deployment configuration"
  },
  "GitHub Actions CI/CD": {
    "prefix": "gcicd-github",
    "body": [
      "name: ${1:Deploy Genkit App}",
      "",
      "on:",
      "  push:",
      "    branches: [${2:main}]",
      "  pull_request:",
      "    branches: [${2:main}]",
      "",
      "jobs:",
      "  test:",
      "    runs-on: ubuntu-latest",
      "    steps:",
      "      - uses: actions/checkout@v3",
      "      - uses: actions/setup-node@v3",
      "        with:",
      "          node-version: '${3:20}'",
      "      - run: npm ci",
      "      - run: npm test",
      "      ",
      "  deploy:",
      "    needs: test",
      "    runs-on: ubuntu-latest",
      "    if: github.ref == 'refs/heads/${2:main}'",
      "    steps:",
      "      - uses: actions/checkout@v3",
      "      - uses: actions/setup-node@v3",
      "        with:",
      "          node-version: '${3:20}'",
      "      - run: npm ci",
      "      - name: Deploy to ${4:Cloud Run}",
      "        env:",
      "          GOOGLE_CREDENTIALS: \\${{ secrets.GOOGLE_CREDENTIALS }}",
      "        run: |",
      "          npm run deploy"
    ],
    "description": "Create GitHub Actions CI/CD workflow"
  },
  "Genkit Evaluator": {
    "prefix": "gevaluate",
    "body": [
      "import { defineEvaluator } from '@genkit-ai/ai/evaluator';",
      "import { z } from 'zod';",
      "",
      "export const ${1:ragEvaluator} = defineEvaluator(",
      "  {",
      "    name: '${1:ragEvaluator}',",
      "    displayName: '${2:RAG Quality Evaluator}',",
      "    definition: '${3:Evaluates RAG response quality}',",
      "    isBilled: false,",
      "  },",
      "  async (datapoint, evaluatorOptions) => {",
      "    const { input, output, context } = datapoint;",
      "    ",
      "    // Evaluate relevance",
      "    const relevance = await ${4:model}.generate({",
      "      prompt: `Rate the relevance of this answer (0-10):\\nQuestion: ${5:\\${input}}\\nAnswer: ${6:\\${output}}`,",
      "    });",
      "    ",
      "    // Evaluate faithfulness",
      "    const faithfulness = await ${4:model}.generate({",
      "      prompt: `Rate how faithful this answer is to the context (0-10):\\nContext: ${7:\\${context}}\\nAnswer: ${6:\\${output}}`,",
      "    });",
      "    ",
      "    return {",
      "      testCaseId: datapoint.testCaseId,",
      "      evaluation: {",
      "        relevance: parseFloat(relevance.text),",
      "        faithfulness: parseFloat(faithfulness.text),",
      "        score: (parseFloat(relevance.text) + parseFloat(faithfulness.text)) / 2,",
      "      },",
      "    };",
      "  }",
      ");"
    ],
    "description": "Create a Genkit evaluator for RAG quality"
  },
  "Genkit Prompt": {
    "prefix": "gprompt",
    "body": [
      "import { definePrompt } from '@genkit-ai/ai';",
      "import { z } from 'zod';",
      "",
      "export const ${1:myPrompt} = definePrompt(",
      "  {",
      "    name: '${1:myPrompt}',",
      "    inputSchema: z.object({",
      "      ${2:context}: z.string(),",
      "      ${3:question}: z.string(),",
      "    }),",
      "  },",
      "  async (input) => {",
      "    return {",
      "      messages: [",
      "        {",
      "          role: 'system',",
      "          content: '${4:You are a helpful assistant.}',",
      "        },",
      "        {",
      "          role: 'user',",
      "          content: `Context:\\n${5:\\${input.${2:context}}}\\n\\nQuestion: ${6:\\${input.${3:question}}}`,",
      "        },",
      "      ],",
      "      config: {",
      "        temperature: ${7:0.7},",
      "      },",
      "    };",
      "  }",
      ");"
    ],
    "description": "Create a structured Genkit prompt"
  },
  "Genkit Chat Flow": {
    "prefix": "gchat",
    "body": [
      "import { defineFlow } from '@genkit-ai/flow';",
      "import { z } from 'zod';",
      "",
      "export const ${1:chatFlow} = defineFlow(",
      "  {",
      "    name: '${1:chatFlow}',",
      "    inputSchema: z.object({",
      "      messages: z.array(z.object({",
      "        role: z.enum(['user', 'assistant', 'system']),",
      "        content: z.string(),",
      "      })),",
      "    }),",
      "    outputSchema: z.string(),",
      "  },",
      "  async (input) => {",
      "    const result = await ${2:model}.generate({",
      "      messages: input.messages,",
      "      config: {",
      "        temperature: ${3:0.7},",
      "        maxTokens: ${4:1000},",
      "      },",
      "    });",
      "    ",
      "    return result.text;",
      "  }",
      ");"
    ],
    "description": "Create a multi-turn chat flow"
  },
  "Genkit Middleware": {
    "prefix": "gmiddleware",
    "body": [
      "import { defineFlow } from '@genkit-ai/flow';",
      "",
      "export const ${1:loggingMiddleware} = defineFlow(",
      "  {",
      "    name: '${1:loggingMiddleware}',",
      "  },",
      "  async (input, { runAction }) => {",
      "    console.log('Request:', JSON.stringify(input, null, 2));",
      "    const startTime = Date.now();",
      "    ",
      "    try {",
      "      const result = await runAction();",
      "      const duration = Date.now() - startTime;",
      "      console.log(`Response (${2:\\${duration}}ms):`, JSON.stringify(result, null, 2));",
      "      return result;",
      "    } catch (error) {",
      "      console.error('Error:', error);",
      "      throw error;",
      "    }",
      "  }",
      ");"
    ],
    "description": "Create Genkit middleware for logging/monitoring"
  },
  "Genkit Batch Processing": {
    "prefix": "gbatch",
    "body": [
      "import { defineFlow } from '@genkit-ai/flow';",
      "import { z } from 'zod';",
      "",
      "export const ${1:batchFlow} = defineFlow(",
      "  {",
      "    name: '${1:batchFlow}',",
      "    inputSchema: z.object({",
      "      items: z.array(z.string()),",
      "      batchSize: z.number().default(10),",
      "    }),",
      "    outputSchema: z.array(z.string()),",
      "  },",
      "  async (input) => {",
      "    const results: string[] = [];",
      "    ",
      "    for (let i = 0; i < input.items.length; i += input.batchSize) {",
      "      const batch = input.items.slice(i, i + input.batchSize);",
      "      ",
      "      const batchResults = await Promise.all(",
      "        batch.map(item => ${2:model}.generate({",
      "          prompt: item,",
      "        }))",
      "      );",
      "      ",
      "      results.push(...batchResults.map(r => r.text));",
      "      ",
      "      // Rate limiting",
      "      if (i + input.batchSize < input.items.length) {",
      "        await new Promise(resolve => setTimeout(resolve, ${3:1000}));",
      "      }",
      "    }",
      "    ",
      "    return results;",
      "  }",
      ");"
    ],
    "description": "Create batch processing flow with rate limiting"
  }
}
