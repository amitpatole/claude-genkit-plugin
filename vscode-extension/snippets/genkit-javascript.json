{
  "Genkit Flow": {
    "prefix": "gflow",
    "body": [
      "const { defineFlow } = require('@genkit-ai/flow');",
      "const { z } = require('zod');",
      "",
      "exports.${1:flowName}Flow = defineFlow(",
      "  {",
      "    name: '${1:flowName}',",
      "    inputSchema: z.object({",
      "      ${2:input}: z.string(),",
      "    }),",
      "    outputSchema: z.${3:string}(),",
      "  },",
      "  async (input) => {",
      "    ${4:// Implement flow logic}",
      "    return ${5:input.${2:input}};",
      "  }",
      ");"
    ],
    "description": "Create a new Genkit flow (JavaScript)"
  },
  "Genkit Config": {
    "prefix": "gconfig",
    "body": [
      "const { configureGenkit } = require('@genkit-ai/core');",
      "const { ${1:claude} } = require('@genkit-ai/${2:anthropic}');",
      "",
      "module.exports = configureGenkit({",
      "  plugins: [",
      "    ${1:claude}({",
      "      apiKey: process.env.${3:ANTHROPIC_API_KEY},",
      "    }),",
      "  ],",
      "  logLevel: '${4:debug}',",
      "  enableTracingAndMetrics: ${5:true},",
      "});"
    ],
    "description": "Create Genkit configuration (JavaScript)"
  },
  "Genkit RAG Flow": {
    "prefix": "grag",
    "body": [
      "const { defineFlow } = require('@genkit-ai/flow');",
      "const { z } = require('zod');",
      "",
      "exports.${1:ragFlow} = defineFlow(",
      "  {",
      "    name: '${1:ragFlow}',",
      "    inputSchema: z.object({",
      "      question: z.string(),",
      "      maxResults: z.number().default(5),",
      "    }),",
      "    outputSchema: z.object({",
      "      answer: z.string(),",
      "      sources: z.array(z.string()),",
      "    }),",
      "  },",
      "  async (input) => {",
      "    // Retrieve relevant documents",
      "    const docs = await ${2:vectorStore}.search(input.question, {",
      "      limit: input.maxResults,",
      "    });",
      "",
      "    // Generate answer with context",
      "    const result = await ${3:model}.generate({",
      "      prompt: `Context:\\n${4:\\${docs.map(d => d.content).join('\\n\\n')}}\\n\\nQuestion: ${5:\\${input.question}}\\n\\nAnswer:`,",
      "    });",
      "",
      "    return {",
      "      answer: result.text,",
      "      sources: docs.map(d => d.id),",
      "    };",
      "  }",
      ");"
    ],
    "description": "Create a RAG flow with Genkit (JavaScript)"
  },
  "Hybrid Search RAG": {
    "prefix": "grag-hybrid",
    "body": [
      "const { defineFlow } = require('@genkit-ai/flow');",
      "const { z } = require('zod');",
      "",
      "exports.${1:hybridSearchRAG} = defineFlow(",
      "  {",
      "    name: '${1:hybridSearchRAG}',",
      "    inputSchema: z.object({",
      "      query: z.string(),",
      "      semanticWeight: z.number().default(0.7),",
      "      keywordWeight: z.number().default(0.3),",
      "    }),",
      "    outputSchema: z.object({",
      "      answer: z.string(),",
      "      sources: z.array(z.object({ id: z.string(), score: z.number() })),",
      "    }),",
      "  },",
      "  async (input) => {",
      "    // Semantic search",
      "    const semanticResults = await ${2:vectorStore}.search(input.query);",
      "    ",
      "    // Keyword search",
      "    const keywordResults = await ${3:fullTextSearch}.search(input.query);",
      "    ",
      "    // Combine and rerank",
      "    const combined = rerank(semanticResults, keywordResults, {",
      "      semanticWeight: input.semanticWeight,",
      "      keywordWeight: input.keywordWeight,",
      "    });",
      "    ",
      "    const answer = await ${4:model}.generate({",
      "      context: combined.map(r => r.content).join('\\n\\n'),",
      "      question: input.query,",
      "    });",
      "    ",
      "    return { answer: answer.text, sources: combined };",
      "  }",
      ");"
    ],
    "description": "Create Hybrid Search RAG flow (JavaScript)"
  },
  "Conversational RAG": {
    "prefix": "grag-conversational",
    "body": [
      "const { defineFlow } = require('@genkit-ai/flow');",
      "const { z } = require('zod');",
      "",
      "exports.${1:conversationalRAG} = defineFlow(",
      "  {",
      "    name: '${1:conversationalRAG}',",
      "    inputSchema: z.object({",
      "      query: z.string(),",
      "      conversationHistory: z.array(z.object({",
      "        role: z.enum(['user', 'assistant']),",
      "        content: z.string(),",
      "      })),",
      "    }),",
      "    outputSchema: z.string(),",
      "  },",
      "  async (input) => {",
      "    // Reformulate query with conversation context",
      "    const contextualQuery = await ${2:model}.generate({",
      "      prompt: `Given the conversation history, reformulate the latest query:\\n${3:\\${JSON.stringify(input.conversationHistory)}}\\n\\nLatest query: ${4:\\${input.query}}\\n\\nReformulated query:`,",
      "    });",
      "    ",
      "    // Retrieve with contextual query",
      "    const docs = await ${5:vectorStore}.search(contextualQuery.text);",
      "    ",
      "    // Generate answer with full context",
      "    const answer = await ${2:model}.generate({",
      "      messages: [",
      "        ...input.conversationHistory,",
      "        { role: 'user', content: `Context:\\n${6:\\${docs.map(d => d.content).join('\\n\\n')}}\\n\\nQuestion: ${4:\\${input.query}}` },",
      "      ],",
      "    });",
      "    ",
      "    return answer.text;",
      "  }",
      ");"
    ],
    "description": "Create Conversational RAG flow (JavaScript)"
  },
  "Pinecone Vector Setup": {
    "prefix": "gvector-pinecone",
    "body": [
      "const { Pinecone } = require('@pinecone-database/pinecone');",
      "const { embed } = require('@genkit-ai/ai');",
      "",
      "const pinecone = new Pinecone({",
      "  apiKey: process.env.PINECONE_API_KEY,",
      "});",
      "",
      "const index = pinecone.Index('${1:your-index-name}');",
      "",
      "async function addDocuments(documents) {",
      "  const vectors = await Promise.all(",
      "    documents.map(async (doc) => ({",
      "      id: doc.id,",
      "      values: await embed({ content: doc.content }),",
      "      metadata: { content: doc.content, ...doc.metadata },",
      "    }))",
      "  );",
      "  ",
      "  await index.upsert(vectors);",
      "}",
      "",
      "async function search(query, limit = 5) {",
      "  const queryVector = await embed({ content: query });",
      "  const results = await index.query({",
      "    vector: queryVector,",
      "    topK: limit,",
      "    includeMetadata: true,",
      "  });",
      "  return results.matches;",
      "}",
      "",
      "module.exports = { addDocuments, search };"
    ],
    "description": "Setup Pinecone vector database (JavaScript)"
  },
  "WebSocket Real-Time Flow": {
    "prefix": "gwebsocket",
    "body": [
      "const { defineFlow } = require('@genkit-ai/flow');",
      "const { z } = require('zod');",
      "const { WebSocket, WebSocketServer } = require('ws');",
      "",
      "const wss = new WebSocketServer({ port: ${1:8080} });",
      "",
      "exports.${2:wsFlow} = defineFlow(",
      "  {",
      "    name: '${2:wsFlow}',",
      "    inputSchema: z.object({",
      "      message: z.string(),",
      "    }),",
      "    outputSchema: z.string(),",
      "  },",
      "  async (input) => {",
      "    const result = await ${3:model}.generate({",
      "      prompt: input.message,",
      "    });",
      "    ",
      "    // Broadcast to all connected clients",
      "    wss.clients.forEach((client) => {",
      "      if (client.readyState === WebSocket.OPEN) {",
      "        client.send(JSON.stringify({",
      "          type: 'response',",
      "          data: result.text,",
      "        }));",
      "      }",
      "    });",
      "    ",
      "    return result.text;",
      "  }",
      ");",
      "",
      "wss.on('connection', (ws) => {",
      "  ws.on('message', async (data) => {",
      "    const message = JSON.parse(data.toString());",
      "    await exports.${2:wsFlow}(message);",
      "  });",
      "});"
    ],
    "description": "Create WebSocket real-time flow (JavaScript)"
  },
  "Server-Sent Events Flow": {
    "prefix": "gsse",
    "body": [
      "const { defineFlow } = require('@genkit-ai/flow');",
      "const { z } = require('zod');",
      "const express = require('express');",
      "",
      "const app = express();",
      "",
      "exports.${1:sseFlow} = defineFlow(",
      "  {",
      "    name: '${1:sseFlow}',",
      "    inputSchema: z.object({",
      "      prompt: z.string(),",
      "    }),",
      "    outputSchema: z.string(),",
      "    streamSchema: z.string(),",
      "  },",
      "  async (input, { stream }) => {",
      "    const result = await ${2:model}.generate({",
      "      prompt: input.prompt,",
      "      stream: true,",
      "    });",
      "    ",
      "    for await (const chunk of result.stream) {",
      "      stream(chunk.text);",
      "    }",
      "    ",
      "    return result.text;",
      "  }",
      ");",
      "",
      "app.get('/stream', async (req, res) => {",
      "  res.setHeader('Content-Type', 'text/event-stream');",
      "  res.setHeader('Cache-Control', 'no-cache');",
      "  res.setHeader('Connection', 'keep-alive');",
      "  ",
      "  const { prompt } = req.query;",
      "  ",
      "  await exports.${1:sseFlow}({ prompt }, {",
      "    stream: (chunk) => {",
      "      res.write(`data: ${3:\\${JSON.stringify({ chunk })}}\\n\\n`);",
      "    },",
      "  });",
      "  ",
      "  res.end();",
      "});",
      "",
      "app.listen(${4:3000});"
    ],
    "description": "Create Server-Sent Events (SSE) streaming flow (JavaScript)"
  },
  "Genkit Model Plugin": {
    "prefix": "gplugin-model",
    "body": [
      "const { defineModel } = require('@genkit-ai/ai/model');",
      "const { z } = require('zod');",
      "",
      "exports.${1:customModel} = defineModel(",
      "  {",
      "    name: '${2:my-provider}/${1:customModel}',",
      "    label: '${3:My Custom Model}',",
      "    supports: {",
      "      multiturn: ${4:true},",
      "      media: ${5:false},",
      "      tools: ${6:true},",
      "      systemRole: ${7:true},",
      "    },",
      "  },",
      "  async (request) => {",
      "    // Call your model API",
      "    const response = await fetch('${8:https://api.example.com/generate}', {",
      "      method: 'POST',",
      "      headers: {",
      "        'Content-Type': 'application/json',",
      "        'Authorization': `Bearer ${9:\\${process.env.API_KEY}}`,",
      "      },",
      "      body: JSON.stringify({",
      "        prompt: request.messages[0].content,",
      "        temperature: request.config?.temperature,",
      "        max_tokens: request.config?.maxTokens,",
      "      }),",
      "    });",
      "    ",
      "    const data = await response.json();",
      "    ",
      "    return {",
      "      message: {",
      "        role: 'model',",
      "        content: [{ text: data.text }],",
      "      },",
      "      finishReason: 'stop',",
      "    };",
      "  }",
      ");"
    ],
    "description": "Create a custom Genkit model plugin (JavaScript)"
  },
  "Multi-Region Config": {
    "prefix": "gregion-config",
    "body": [
      "module.exports = {",
      "  strategy: '${1|active-active,active-passive,geo-routing|}',",
      "  regions: [",
      "    {",
      "      name: '${2:us-central1}',",
      "      primary: ${3:true},",
      "      weight: ${4:50},",
      "      endpoints: {",
      "        api: 'https://${2:us-central1}.example.com',",
      "        health: 'https://${2:us-central1}.example.com/health',",
      "      },",
      "    },",
      "    {",
      "      name: '${5:europe-west1}',",
      "      primary: ${6:false},",
      "      weight: ${7:50},",
      "      endpoints: {",
      "        api: 'https://${5:europe-west1}.example.com',",
      "        health: 'https://${5:europe-west1}.example.com/health',",
      "      },",
      "    },",
      "  ],",
      "  failover: {",
      "    enabled: ${8:true},",
      "    healthCheckInterval: ${9:30000},",
      "    retryAttempts: ${10:3},",
      "  },",
      "};"
    ],
    "description": "Create multi-region deployment configuration (JavaScript)"
  },
  "Genkit Chat Flow": {
    "prefix": "gchat",
    "body": [
      "const { defineFlow } = require('@genkit-ai/flow');",
      "const { z } = require('zod');",
      "",
      "exports.${1:chatFlow} = defineFlow(",
      "  {",
      "    name: '${1:chatFlow}',",
      "    inputSchema: z.object({",
      "      messages: z.array(z.object({",
      "        role: z.enum(['user', 'assistant', 'system']),",
      "        content: z.string(),",
      "      })),",
      "    }),",
      "    outputSchema: z.string(),",
      "  },",
      "  async (input) => {",
      "    const result = await ${2:model}.generate({",
      "      messages: input.messages,",
      "      config: {",
      "        temperature: ${3:0.7},",
      "        maxTokens: ${4:1000},",
      "      },",
      "    });",
      "    ",
      "    return result.text;",
      "  }",
      ");"
    ],
    "description": "Create a multi-turn chat flow (JavaScript)"
  },
  "Genkit Streaming Flow": {
    "prefix": "gstream",
    "body": [
      "const { defineFlow } = require('@genkit-ai/flow');",
      "const { z } = require('zod');",
      "",
      "exports.${1:streamFlow} = defineFlow(",
      "  {",
      "    name: '${1:streamFlow}',",
      "    inputSchema: z.object({",
      "      prompt: z.string(),",
      "    }),",
      "    outputSchema: z.string(),",
      "    streamSchema: z.string(),",
      "  },",
      "  async (input, { stream }) => {",
      "    ${2:// Implement streaming logic}",
      "    for (const ${3:chunk} of ${4:chunks}) {",
      "      stream(${3:chunk});",
      "      await new Promise(resolve => setTimeout(resolve, ${5:100}));",
      "    }",
      "    return ${6:'Complete response'};",
      "  }",
      ");"
    ],
    "description": "Create a streaming Genkit flow (JavaScript)"
  }
}
